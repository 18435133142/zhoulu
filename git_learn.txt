git 学习记录1.git开发源码：C语言2.初始化git仓库：git init3.添加文件到git仓库：git add 文件名 实际上就是把文件修改添加到暂存区. 有时候因为.gitignore的存在会导致文件不能加入进去，这时可以使用-f 强制添加。 git add -f 文件名4.提交文件到git：git commit -m "提交信息，与提交内容相关。"   实际上就是把暂存区的所有内容提交到当前分支. 注意，git commit只会提交暂存区的内容，本地修改	后没有添加至暂存区的话是不会提交的。	5.获取Git文件状态（是否有修改等）：git status6.获取Git文件具体修改内容：git diff	小结		要随时掌握工作区的状态，使用git status命令。		如果git status告诉你有文件被修改过，用git diff可以查看修改内容。		7.查看git文件从最近到最远提交日志：git log		直线的形式：git log --graph --pretty=oneline --abbrev-commit8.git回到过去某版本：git reset --hard HEAD^  用HEAD表示当前版本，也就是最新的提交1094adb...（提交ID，git自动生成的），	上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。	9.git回到未来某版本：git reset --hard 版本id   Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，	Git仅仅是把HEAD从指向旧版本的指向指定的版本	10.git仓库查找使用过的每一次指令（可用于回退版本时查找指令的ID，ID可用于切换版本）：git reflog	小结		HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。		穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。		要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。		11.Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。	工作区（Working Directory）：就是你在电脑里能看到的目录。	版本库（Repository）：工作区有一个隐藏目录.git文件，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，		其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。		12.为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。（体现：Git只会提交暂存区的内容，对于本地修改未添加至暂存区的内容是不会提交的）13.工作区和版本库里面最新版本的区别 git diff HEAD -- 文件名14.丢弃工作区的修改内容（把内容回退到未修改之前）：git checkout -- 文件名。意思就是，把XX文件在工作区的修改全部撤销	这里有两种情况：	一种是XX文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；	一种是XX文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。15.把暂存区的修改（使用Git add命令添加至暂存区的文件）撤销掉（unstage），重新放回工作区：git reset HEAD 文件名。git reset命令既可以回退版本，	也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。16.删除git仓库文件：git rm 文件名  可将本地文件删除，删除版本库的文件还需要git commit进行提交。（如果删错文件了，可以使用git checkout -- 文件名 进行恢复。）	git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。17.关联远程库：git remote add origin git@远程库地址   关联后使用git push -u origin master第一次推送master分支的所有内容	此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。	小结：		要关联一个远程库，使用命令 git remote add origin git@远程库地址；  删除已关联的远程库：git remote rm origin		关联后，使用命令 git push -u origin master 第一次推送master分支的所有内容；		此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；		分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，		而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！18.克隆远程仓库：git clone git@远程地址    Git支持多种协议，包括https，但ssh协议速度最快。19.分支管理	每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，	即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。   分支合并：   比如在master节点创建一个dev分支，然后在dev分支上提交代码后，如要将dev分支合并到master上，就是直接把master指向dev的当前提交。   合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支   20.创建分支：git branch 分支名   切换分支：git checkout 分支名   创建分支同时切换至创建的分支：git checkout -b 分支名   删除分支：git branch -d 分支名  删除指定分支(尚未合并的分支使用-d删除失败，可使用-D强行删除尚未合并的分支)   查看当前分支：git branch      git branch命令会列出所有分支，当前分支前面会标一个*号   合并分支：git merge 分支名   git merge命令用于合并指定分支到当前分支		因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。		当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。		解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。		用git log --graph命令可以看到分支合并图。   查看分支历史：git log --graph --pretty=oneline --abbrev-commit   分支策略：		在实际开发中，我们应该按照几个基本原则进行分支管理：		首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；		那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；		你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。		合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。21.分支缓存工作现场：git stash		修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；		当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；		在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>(id)命令，把bug提交的修改“复制”到当前分支，避免重复劳动。22.查看远程库的信息：git remote  使用git remote -v可以查看更加详细的信息23.推送分支：git push origin 分支名称	设置dev分支与远程dev分支的联系：git branch --set-upstream-to=origin/dev dev	创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： git checkout -b dev origin/dev	24.抓取代码：git fetch      git pull	小结		查看远程库信息，使用git remote -v；		本地新建的分支如果不推送到远程，对其他人就是不可见的；		从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；		在本地创建和远程分支对应的分支，使用：git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；		建立本地分支和远程分支的关联，使用：git branch --set-upstream-to branch-name origin/branch-name；		从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。25.将git分叉提交历史整理成直线：git rebase操作可以把本地未push的分叉提交历史整理成直线；		rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比		26.标签管理：发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，		就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针		（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。所以，tag（例如 v1.2）就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。27.git给某个提交打标签：git tag v1.0(标签名，也就是版本号之类的)   默认标签是打在最新提交的commit上的。	给指定的某个commit提交打标签：git tag v0.9（标签名） f52c633（commit ID）	还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：git tag -a v0.1（标签名） -m "version 0.1 released" 1094adb（commit ID）	删除标签：git tag -d v1.0(标签名)   如果标签打错了，也可以删除：因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。		如果要推送某个标签到远程，使用命令git push origin <tagname>：一次性推送全部的标签：git push origin --tags  如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：		然后，从远程删除。删除命令也是push，但是格式如下：git push origin :refs/tags/v0.9	查看所有已有的标签：git tag	查看某个标签的具体信息：git show v1.0(标签名)	28.忽略某些不需要提交的文件：根目录下创建一个 .gitignore文件把需要忽略的文件名加进去	排除写法：.* 排除所有.开头的文件    *.class 排除所有的class文件	不排除写法：!.gitignore 不排除.gitignore 文件	忽略文件的原则是：		忽略操作系统自动生成的文件，比如缩略图等；		忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；		忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。29.git命令配置别名：git config --global alias.st status 之后就可以使用git st命令