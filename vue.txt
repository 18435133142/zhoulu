计算属性：计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。
	1、在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。
	除了上例简单的用法，计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。
	2、getter 和 setter 方法  计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter 
	   每一个计算属性都包含一个 getter 方法和一个 setter 方法。
	3、如果计算属性后面直接跟一个 function，使用的就是计算属性的默认方法 getter 来读取。
	4、我们也可以在需要时使用 setter 函数 ， 当手动修改计算属性的值就像修改一个普通数据那样时，就会触发 setter 函数，执行一些自定义的操作。

计算属性与$watch比较：Vue.js 提供了一个方法 $watch ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， $watch 
	很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 $watch 回调。
	但是使用$watch有时候会重复很多代码，这时就需要使用计算属性。但是具体使用计算属性还是$watch还得看实际情况：
	例：
	使用$watch
	data: {
	  firstName: 'Foo',
	  lastName: 'Bar',
	  fullName: 'Foo Bar'
    },
    watch: {
	  firstName: function (val) {
	    this.fullName = val + ' ' + this.lastName
	  },
	  lastName: function (val) {
	    this.fullName = this.firstName + ' ' + val
	  }
    }
	使用计算属性：
	data: {
		firstName: 'Foo',
		lastName: 'Bar'
	  },
	  computed: {
		fullName: function () {
		  return this.firstName + ' ' + this.lastName
		}
	  }
	  
深入响应式原理：Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，
	修改它则更新视图(view)。这会让状态管理变得非常简单且直观，
	把一个普通 Javascript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 
	getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。
	getter/setter 对于用户来说是不可见的，但是基于此内部机制，可以使 Vue 在属性被访问和修改时去触发相应的 getter 和 setter，
	以实现依赖追踪(dependency-track)和变更通知(change-notification)。
	
	变化检测问题：受现代 Javascript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行
	getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。Vue 不允许在已经创建的实例上动态添加新的根级
	响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：也可以使用this.$set(this.someObject,'b',2)
	进行设置，这也是全局 Vue.set 方法的别名。
	
	声明响应式属性：由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:
	data: {
		// 声明 message 为一个空值字符串
		message: ''
	  },
	如果你在 data 选项中未声明 message，Vue 将警告你渲染函数在试图访问的属性不存在。
	























































